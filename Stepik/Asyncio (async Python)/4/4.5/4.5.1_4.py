import asyncio


async def task(lock):                           
    print('Задача приобретает блокировку...')   
    # Приобретаем блокировку
    async with lock:         

        # Генерируем исключение, симулируя ошибку               
        raise Exception('Произошло что-то плохое')  
    
    # освобождаем блокировку (сюда никогда не дойдем)
    print('Задача освобождает блокировку...')   
                              



async def main(): 
    lock = asyncio.Lock()                                
    await asyncio.create_task(task(lock))                      
    await asyncio.sleep(1)                               
    print('Основная функция приобретает блокировку...')  
    # Используем метод acquire() для асинхронного приобретения блокировки
    await lock.acquire()                                 
    
    # освобождаем блокировку (сюда никогда не дойдем)
    # Освобождаем блокировку методом release(). 
    # Но этот код не будет выполнен, так как предыдущий вызов acquire() не будет завершен, поскольку задача, 
    # которая первоначально приобрела блокировку, не освободила ее из-за ошибки
    lock.release()                                     


asyncio.run(main())